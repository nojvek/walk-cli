#!/usr/bin/env node
var c, errors, exec, help, options, opts, parseArgs, walk, walkCount, walkOpts;

options = require('options-parser');

walk = require('./walk');

exec = require('child_process').exec;

c = console;

errors = [];

walkOpts = {};

String.prototype.repeat = function(n) {
  return Array(n + 1).join(this);
};

opts = {
  files: {
    help: "List files? Default y",
    short: 'f',
    "default": 'y'
  },
  dirs: {
    help: "List directories? Default n",
    short: 'd',
    "default": 'n'
  },
  recurse: {
    help: "Recurse child directories? Default y",
    short: 'r',
    "default": 'y'
  },
  symLinks: {
    help: "Recurse symbolic links? Default y",
    short: 's',
    "default": 'y'
  },
  name: {
    help: "Only show files or directories matching regex filter. e.g -name ^walk",
    short: 'n'
  },
  ignore: {
    help: "ignore files or directories matching regex filter. e.g -i '.git|node_modules'",
    short: 'i'
  },
  ext: {
    help: "Only show files matching extension. e.g -e js",
    short: 'e'
  },
  maxDepth: {
    help: "Only recurse until a specific depth. e.g -m 3",
    short: 'm'
  },
  exec: {
    help: "For each entry execute following command. e.g -x 'echo $i $name $path $level $size $mtime' -x 'cat $path'.",
    short: 'x',
    multi: true
  },
  tree: {
    help: "Show output as indented tree?",
    short: 't',
    flag: true
  },
  help: {
    help: "Show this help menu",
    short: 'h',
    flag: true
  }
};

help = function() {
  c.log("Usage:", process.argv[0], "[options (VAL = y|n)]");
  return options.help(opts, {
    output: c.log
  });
};

parseArgs = function() {
  var arg, args, parsed, ref, val;
  args = {};
  parsed = options.parse(opts, process.argv, function(error) {
    var key, results, val;
    results = [];
    for (key in error) {
      val = error[key];
      results.push(errors.push("  " + key + " " + val));
    }
    return results;
  });
  ref = parsed.opt;
  for (arg in ref) {
    val = ref[arg];
    if (val === 'y') {
      val = true;
    } else if (val === 'n') {
      val = false;
    }
    args[arg] = val;
  }
  if (args.tree) {
    args.dirs = true;
  }
  if (args.maxDepth) {
    args.maxDepth = parseInt(args.maxDepth);
  }
  if (errors.length) {
    c.error("Invalid arguments");
    c.error(errors.join("\n"));
    help();
    process.exit(1);
  } else if (args.help) {
    help(0);
    process.exit(0);
  }
  return args;
};


/* main */

walkOpts = parseArgs();

walkCount = 0;

walk(walkOpts, function(path, name, level, stat) {
  var cmd, i, key, len, ref, replacers, results, val;
  if (walkOpts.tree) {
    return c.log("|  ".repeat(level) + name);
  } else {
    if (walkOpts.exec) {
      walkCount += 1;
      replacers = {
        i: walkCount,
        path: path,
        name: name,
        level: level,
        size: stat.size,
        mtime: stat.mtime.getTime() / 1000,
        ctime: stat.ctime.getTime() / 1000
      };
      ref = walkOpts.exec;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        cmd = ref[i];
        for (key in replacers) {
          val = replacers[key];
          cmd = cmd.replace(new RegExp("\\$" + key, "g"), val);
        }
        results.push(exec(cmd, function(error, stdout, stderr) {
          if (stdout) {
            process.stdout.write(stdout);
          }
          if (stderr) {
            return process.stderr.write(stderr);
          }
        }));
      }
      return results;
    } else {
      return c.log(path);
    }
  }
});
